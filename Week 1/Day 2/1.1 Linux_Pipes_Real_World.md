# pipe Command in Linux

## Overview
The pipe command in Linux, represented by the vertical bar symbol '|', is an essential tool for command-line enthusiasts and professionals alike. The primary purpose of the pipe command is to connect the output of one command directly into the input of another. This command allows users to chain multiple commands together in a single line, thereby improving efficiency and enabling the creation of more complex commands.

## Syntax of pipe Command in Linux
The basic syntax of the pipe command in Linux is as follows:

`command1 | command2`

Where:

**command1:** This is the initial command whose output will serve as input to the next command.

**| (pipe symbol):** This symbol is the pipe command itself. It facilitates the transfer of output from command1 into command2.

**command2:** This is the subsequent command that receives the output of command1 as its input.

Options in pipe Command in Linux

Example Usages

Pipe command to filter directory listing:

`ls -l | grep '.txt'`

Output:

A list of .txt files in the current directory
---

A **pipe (`|`)** sends the **output of one command** to the **input of the next**.

**General pattern**
```bash
command1 | command2 | command3
```

> **Rule:** Each command does *one job*. Pipes combine them into a workflow.

---

## 0) Setup a Small Real Dataset (Recommended)

Run these once to create sample files:

```bash
mkdir -p pipe_lab
cd pipe_lab
```

### 0.1 App Log
```bash
cat > app.log << 'EOF'
2025-12-15 09:00:01 INFO  User login success user=rahul ip=10.0.0.11
2025-12-15 09:01:20 WARN  Slow query user=sonali ip=10.0.0.12 ms=2400
2025-12-15 09:02:10 ERROR DB connection failed user=rahul ip=10.0.0.11 code=DB100
2025-12-15 09:03:40 INFO  Order placed user=arjun ip=10.0.0.13 amount=499
2025-12-15 09:04:15 ERROR Payment failed user=sonali ip=10.0.0.12 code=PAY200
2025-12-15 09:05:05 INFO  User logout user=rahul ip=10.0.0.11
2025-12-15 09:06:30 WARN  API timeout user=arjun ip=10.0.0.13 ms=5200
2025-12-15 09:07:00 ERROR API returned 500 user=arjun ip=10.0.0.13 code=API500
EOF
```

### 0.2 Access Log
```bash
cat > access.log << 'EOF'
10.0.0.11 - - [15/Dec/2025:09:00:01 +0530] "GET /login HTTP/1.1" 200 123
10.0.0.12 - - [15/Dec/2025:09:01:20 +0530] "GET /products HTTP/1.1" 200 533
10.0.0.11 - - [15/Dec/2025:09:02:10 +0530] "POST /pay HTTP/1.1" 500 321
10.0.0.13 - - [15/Dec/2025:09:03:40 +0530] "GET /orders HTTP/1.1" 200 444
10.0.0.12 - - [15/Dec/2025:09:04:15 +0530] "POST /pay HTTP/1.1" 502 311
10.0.0.13 - - [15/Dec/2025:09:06:30 +0530] "GET /status HTTP/1.1" 200 88
10.0.0.13 - - [15/Dec/2025:09:07:00 +0530] "GET /status HTTP/1.1" 500 88
EOF
```

### 0.3 Sales CSV
```bash
cat > sales.csv << 'EOF'
order_id,customer,city,amount,status
O1001,Rahul,Chennai,499,PAID
O1002,Sonali,Bengaluru,1200,FAILED
O1003,Arjun,Hyderabad,799,PAID
O1004,Rahul,Chennai,1500,PAID
O1005,Sonali,Bengaluru,300,FAILED
EOF
```

---

## 1) Count How Many `ERROR` Lines Are in a Log

**Goal:** “How many errors happened?”

```bash
grep "ERROR" app.log | wc -l
```

---

## 2) Show Last 2 Errors (Recent)

```bash
grep "ERROR" app.log | tail -n 2
```

---

## 3) Unique Error Codes from the Log

```bash
grep "ERROR" app.log | grep -o "code=[A-Z0-9]*" | sort | uniq
```

---

## 4) Top Users Who Caused Errors (Frequency)

```bash
grep "ERROR" app.log | grep -o "user=[a-z]*" | sort | uniq -c | sort -nr
```

---

## 5) Top IPs from Access Logs (Traffic / Security)

```bash
cut -d' ' -f1 access.log | sort | uniq -c | sort -nr | head -n 5
```

---

## 6) Count Failing HTTP Status Codes (500 / 502)

```bash
grep -E ' (500|502) ' access.log | awk '{print $9}' | sort | uniq -c | sort -nr
```

---

## 7) Watch Errors Live (Real‑Time)

```bash
tail -f app.log | grep --line-buffered "ERROR"
```

---

## 8) Extract City from CSV and Uppercase It

```bash
cut -d',' -f3 sales.csv | tail -n +2 | tr 'a-z' 'A-Z'
```

---

## 9) Total Amount of PAID Orders (CSV Sum)

```bash
tail -n +2 sales.csv | grep ",PAID$" | awk -F',' '{sum += $4} END {print sum}'
```

---

## 10) Count Endpoints Hit in Access Log

```bash
awk -F'"' '{print $2}' access.log | awk '{print $2}' | sort | uniq -c | sort -nr
```

---

## 11) Normalize Spaces (Clean Text)

```bash
tr -s ' ' < app.log
```

---

## 12) Top 10 Largest Files in a Folder

```bash
du -ah . | sort -hr | head -n 10
```

---

## 13) Extract Usernames from `/etc/passwd`

```bash
cut -d: -f1 /etc/passwd | sort | head
```

---

## 14) Find All `.log` Files and Count Lines

```bash
find . -name "*.log" | xargs wc -l
```

**Safer for filenames with spaces**
```bash
find . -name "*.log" -print0 | xargs -0 wc -l
```

---

## 15) Save Pipeline Output into a Report File

```bash
grep "ERROR" app.log | grep -o "code=[A-Z0-9]*" | sort | uniq -c | sort -nr > error_report.txt
cat error_report.txt
```

---

## Quick Cheat Sheet

- `grep` → filter lines  
- `sort` → sort lines  
- `uniq -c` → unique + count  
- `head` / `tail` → top / bottom lines  
- `cut` → split columns  
- `tr` → replace / convert characters  
- `awk` → field processing + calculations  
- `sed` → replace / edit text  

---

## What a Pipe (`|`) Really Does

The pipe takes the **output** of the left command and gives it as **input** to the right command.

Think of it like **water flow**:

```
Command A (produces text) → | → Command B (filters / transforms)
```

### Example: Count ERROR Lines
```bash
grep "ERROR" app.log | wc -l
```
**Meaning:** There are *N* error lines in the log.

> Tip: You don’t always need `cat`.  
> Prefer `grep "ERROR" app.log` over `cat app.log | grep "ERROR"`.
