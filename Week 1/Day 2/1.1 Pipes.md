Linux Pipes (|) — Many Real-World Examples (Step-by-Step)

A pipe (|) sends the output of one command to the input of the next.

General pattern:

command1 | command2 | command3


Rule: Each command does one job, and pipes combine them into a workflow.

0) Setup a small “real” dataset (recommended)

Run these once to create sample files:

mkdir -p pipe_lab
cd pipe_lab

# 1) Sample app log
cat > app.log << 'EOF'
2025-12-15 09:00:01 INFO  User login success user=rahul ip=10.0.0.11
2025-12-15 09:01:20 WARN  Slow query user=sonali ip=10.0.0.12 ms=2400
2025-12-15 09:02:10 ERROR DB connection failed user=rahul ip=10.0.0.11 code=DB100
2025-12-15 09:03:40 INFO  Order placed user=arjun ip=10.0.0.13 amount=499
2025-12-15 09:04:15 ERROR Payment failed user=sonali ip=10.0.0.12 code=PAY200
2025-12-15 09:05:05 INFO  User logout user=rahul ip=10.0.0.11
2025-12-15 09:06:30 WARN  API timeout user=arjun ip=10.0.0.13 ms=5200
2025-12-15 09:07:00 ERROR API returned 500 user=arjun ip=10.0.0.13 code=API500
EOF

# 2) Sample access log
cat > access.log << 'EOF'
10.0.0.11 - - [15/Dec/2025:09:00:01 +0530] "GET /login HTTP/1.1" 200 123
10.0.0.12 - - [15/Dec/2025:09:01:20 +0530] "GET /products HTTP/1.1" 200 533
10.0.0.11 - - [15/Dec/2025:09:02:10 +0530] "POST /pay HTTP/1.1" 500 321
10.0.0.13 - - [15/Dec/2025:09:03:40 +0530] "GET /orders HTTP/1.1" 200 444
10.0.0.12 - - [15/Dec/2025:09:04:15 +0530] "POST /pay HTTP/1.1" 502 311
10.0.0.13 - - [15/Dec/2025:09:06:30 +0530] "GET /status HTTP/1.1" 200 88
10.0.0.13 - - [15/Dec/2025:09:07:00 +0530] "GET /status HTTP/1.1" 500 88
EOF

# 3) Sample CSV
cat > sales.csv << 'EOF'
order_id,customer,city,amount,status
O1001,Rahul,Chennai,499,PAID
O1002,Sonali,Bengaluru,1200,FAILED
O1003,Arjun,Hyderabad,799,PAID
O1004,Rahul,Chennai,1500,PAID
O1005,Sonali,Bengaluru,300,FAILED
EOF

1) Count how many ERROR lines are in a log

Goal: “How many errors happened?”

Step 1 — filter errors

grep "ERROR" app.log


Step 2 — count lines

grep "ERROR" app.log | wc -l

2) Show last 2 ERRORs (recent errors)
grep "ERROR" app.log | tail -n 2

3) Unique error codes from the log

Step 1 — error lines

grep "ERROR" app.log


Step 2 — extract code

grep "ERROR" app.log | grep -o "code=[A-Z0-9]*"


Step 3 — unique

grep "ERROR" app.log | grep -o "code=[A-Z0-9]*" | sort | uniq

4) Top users who caused errors (frequency)
grep "ERROR" app.log | grep -o "user=[a-z]*" | sort | uniq -c | sort -nr

5) Top IPs from access logs (traffic/security)

Step 1 — extract IP

cut -d' ' -f1 access.log


Step 2 — count

cut -d' ' -f1 access.log | sort | uniq -c


Step 3 — top 5

cut -d' ' -f1 access.log | sort | uniq -c | sort -nr | head -n 5

6) Count failing HTTP status codes (500/502)

Step 1 — filter 500/502

grep -E ' (500|502) ' access.log


Step 2 — extract status code + count

grep -E ' (500|502) ' access.log | awk '{print $9}' | sort | uniq -c | sort -nr

7) Watch errors live (real-time)
tail -f app.log | grep --line-buffered "ERROR"

8) Extract city from CSV and uppercase it
cut -d',' -f3 sales.csv | tail -n +2 | tr 'a-z' 'A-Z'

9) Total amount of PAID orders (CSV sum)
tail -n +2 sales.csv | grep ",PAID$" | awk -F',' '{sum += $4} END {print sum}'

10) Count endpoints hit in access log
awk -F'"' '{print $2}' access.log | awk '{print $2}' | sort | uniq -c | sort -nr

11) Normalize spaces (clean text)
cat app.log | tr -s ' '

12) Top 10 largest files in a folder
du -ah . | sort -hr | head -n 10

13) Extract usernames from /etc/passwd
cut -d: -f1 /etc/passwd | sort | head

14) Find all .log files and count lines (xargs)
find . -name "*.log" | xargs wc -l


Safer for filenames with spaces:

find . -name "*.log" -print0 | xargs -0 wc -l

15) Save pipeline output into a report file
grep "ERROR" app.log | grep -o "code=[A-Z0-9]*" | sort | uniq -c | sort -nr > error_report.txt
cat error_report.txt

Quick Cheat Sheet (most used filters)

grep → filter lines

sort → sort lines

uniq -c → unique + count

head / tail → top/bottom lines

cut → split columns

tr → replace/convert chars

awk → field processing + calculations

sed → replace/edit text

What a Pipe | REALLY does

| takes the output of the left command and gives it as input to the right command.

Think of it like water flow:

Command A (produces text) → pipe → Command B (filters/changes that text)

Example 1: Count ERROR lines in a log (most common real-world use)
File: app.log contains:
INFO  App started
ERROR DB failed
INFO  Retry
ERROR Payment failed

Step 1 — Read the file (output everything)
cat app.log


Output: shows all lines (INFO + ERROR)

Step 2 — Filter only ERROR lines
cat app.log | grep "ERROR"


Explanation:

cat app.log prints all lines (output)

| sends those lines into grep

grep "ERROR" keeps only lines that contain ERROR

Output:

ERROR DB failed
ERROR Payment failed

Step 3 — Count how many ERROR lines
cat app.log | grep "ERROR" | wc -l


Explanation:

cat outputs all lines

pipe → grep filters only ERROR lines

pipe → wc -l counts how many lines are left

Output:

2


✅ Meaning: There are 2 errors in the log.

Example 2: “Top IP addresses” from access logs (very real-world)
File: access.log contains lines like:
10.0.0.11 GET /login
10.0.0.12 GET /products
10.0.0.11 POST /pay
10.0.0.13 GET /orders
10.0.0.11 GET /status

Step 1 — Take only the IP column (1st column)
cut -d' ' -f1 access.log


Explanation:

-d' ' means delimiter is space

-f1 means “field 1” (first column)

Output:

10.0.0.11
10.0.0.12
10.0.0.11
10.0.0.13
10.0.0.11

Step 2 — Sort the IPs (so same IPs come together)
cut -d' ' -f1 access.log | sort


Output:

10.0.0.11
10.0.0.11
10.0.0.11
10.0.0.12
10.0.0.13

Step 3 — Count duplicates (uniq -c counts repeated lines)
cut -d' ' -f1 access.log | sort | uniq -c


Output:

3 10.0.0.11
1 10.0.0.12
1 10.0.0.13


✅ Meaning: IP 10.0.0.11 visited 3 times.

Step 4 — Show highest first (descending)
cut -d' ' -f1 access.log | sort | uniq -c | sort -nr

Example 3: Show last 5 errors only (common for debugging)
Step 1 — Filter errors
grep "ERROR" app.log

Step 2 — Take only last 5
grep "ERROR" app.log | tail -n 5


Explanation:

grep outputs only ERROR lines

pipe → tail takes last 5 of those

Important: You don’t always need cat

These two are same:

cat app.log | grep "ERROR"
grep "ERROR" app.log


Second one is preferred.